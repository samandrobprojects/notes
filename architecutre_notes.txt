The major concerns of architecture:
 - Function                       - Does it work the way we want
 - Seperation of Components       - Is everything seperated out properly
 - Data Management                - Our programs are just control and data

Paradigms:
Each paradigm removes capabilities from the programmer, imposing extra discipline on the programmer. They less tell the programmer
what to do, and more tell the programmer what not to do.

1. Structured Programming: Algorithmic foundation of our modules
2. OO: Polymorphism is the mechanism to cross architectural boundaries.
3. Functional programming: Impose discipline on location of and access to data

Structered Programming
Unrestrained use of goto made proofs for programs difficult, making them unable to be broken down into smaller units. Instead,
the "if else" and "do/while" constructs exclusively represent all options, as well as allow programs to be decomposed into smaller
units.

Three constructs can represent all programs, selection, iteration, and sequence. The exact structures that make a program proveable,
are also the minimum neccessary to represent them.

Science does not work by proving statements true, but rather by proving statements false. I.e "falsifiable, not proveable".

Dijstra said that tests show the presence, not the absence, of bugs. A program can hence be proven incorrect by a test, but
not proven correct.

What we achieve with structered programming is hence two things:
1. Falsifiable units, and hence testable units, otherwise testing would be impossible
2. Functional decomposition, which makes everything possible.

Object Oriented Programming
What is OO? On unsatisfactory answer is "combination of data and function", but this is unsatisfying, because it implies
f(o) is somehow different from o.f(). People were still passing data structures into functions.

Encapsulation?
This is saying that outside of a point the data is hidden and only some functions are avaliable.
Well, we actually have perfect encapsulation in C.

I.e if we consider the following to be point.h

struct Point;
struct Point* makePoint(double x, double y);
double distance(struct Point *p1, struct Point *p2);

(Martin, Robert C.. Clean Architecture (Robert C. Martin Series) (p. 35). Pearson Education. Kindle Edition.)

In Java, they abolished the header/implementation split altogether, so there is not perfect encapsulation there either.

Inheritance?
This is simply the redeclaration of a group of variables and functions within an enclosing scope.

int main(int ac, char** av) {
  struct NamedPoint* origin = makeNamedPoint(0.0, 0.0, "origin");
  struct NamedPoint* upperRight = makeNamedPoint (1.0, 1.0, "upperRight");
  printf("distance=%f\n",
    distance(
             (struct Point*) origin, 
             (struct Point*) upperRight));
}

Martin, Robert C.. Clean Architecture (Robert C. Martin Series) (p. 39). Pearson Education. Kindle Edition. 

This shows in C some trickery, since we can cast one to the other and use it in the same way, but we are also forced to
use explicit casting, which is not as neat as the implicit casting with inheritance in OO.

Polymorphism?
